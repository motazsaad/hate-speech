{"cells":[{"cell_type":"markdown","metadata":{"id":"OoI1jDpua-wl"},"source":["# English-to-Spanish translation with a sequence-to-sequence Transformer\n","\n","**Author:** [fchollet](https://twitter.com/fchollet)\u003cbr\u003e\n","**Date created:** 2021/05/26\u003cbr\u003e\n","**Last modified:** 2021/05/26\u003cbr\u003e\n","**Description:** Implementing a sequence-to-sequene Transformer and training it on a machine translation task."]},{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":55399,"status":"ok","timestamp":1630058014135,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"bTHMBYKRbi1T","outputId":"6e4a408a-e262-4310-c66b-24dabae374cc"},"outputs":[{"name":"stdout","output_type":"stream","text":["Mounted at /content/drive\n"]}],"source":["from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"markdown","metadata":{"id":"QC6rAuTna-wp"},"source":["## Introduction\n","\n","In this example, we'll build a sequence-to-sequence Transformer model, which\n","we'll train on an English-to-Spanish machine translation task.\n","\n","You'll learn how to:\n","\n","- Vectorize text using the Keras `TextVectorization` layer.\n","- Implement a `TransformerEncoder` layer, a `TransformerDecoder` layer,\n","and a `PositionalEmbedding` layer.\n","- Prepare data for training a sequence-to-sequence model.\n","- Use the trained model to generate translations of never-seen-before\n","input sentences (sequence-to-sequence inference).\n","\n","The code featured here is adapted from the book\n","[Deep Learning with Python, Second Edition](https://www.manning.com/books/deep-learning-with-python-second-edition)\n","(chapter 11: Deep learning for text).\n","The present example is fairly barebones, so for detailed explanations of\n","how each building block works, as well as the theory behind Transformers,\n","I recommend reading the book."]},{"cell_type":"markdown","metadata":{"id":"7il3-WZPa-wr"},"source":["## Setup"]},{"cell_type":"code","execution_count":2,"metadata":{"executionInfo":{"elapsed":25,"status":"ok","timestamp":1630058014141,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"ctfudCVLVpA6"},"outputs":[],"source":["# !pip install --upgrade tensorflow\n","# !pip install --upgrade tensorflow-gpu"]},{"cell_type":"code","execution_count":3,"metadata":{"executionInfo":{"elapsed":2492,"status":"ok","timestamp":1630058016611,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"mxIpmPJfa-ws"},"outputs":[],"source":["import pathlib\n","import random\n","import string\n","import re\n","import numpy as np\n","import tensorflow as tf\n","from tensorflow import keras\n","from tensorflow.keras import layers\n","from tensorflow.keras.layers.experimental.preprocessing import TextVectorization"]},{"cell_type":"markdown","metadata":{"id":"6WkEVy-Za-wt"},"source":["## Downloading the data\n","\n","We'll be working with an English-to-Spanish translation dataset\n","provided by [Anki](https://www.manythings.org/anki/). Let's download it:"]},{"cell_type":"code","execution_count":4,"metadata":{"executionInfo":{"elapsed":40,"status":"ok","timestamp":1630058016612,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"W8FYDJLEa-wu"},"outputs":[],"source":["# text_file = keras.utils.get_file(\n","#     fname=\"spa-eng.zip\",\n","#     origin=\"http://storage.googleapis.com/download.tensorflow.org/data/spa-eng.zip\",\n","#     extract=True,\n","# )\n","# text_file = pathlib.Path('/content/drive/MyDrive/MasterThesis/paraphrasing/ParapgrasingMask/Parapgrasing - Masking - maskWithWords.tsv')\n","\n","text_file = pathlib.Path('/content/drive/MyDrive/MasterThesis/paraphrasing/ParapgrasingMask/ParapgrasingMasking.tsv')"]},{"cell_type":"markdown","metadata":{"id":"3GIGj5-Qa-wv"},"source":["## Parsing the data\n","\n","Each line contains an English sentence and its corresponding Spanish sentence.\n","The English sentence is the *source sequence* and Spanish one is the *target sequence*.\n","We prepend the token `\"[start]\"` and we append the token `\"[end]\"` to the Spanish sentence."]},{"cell_type":"code","execution_count":5,"metadata":{"executionInfo":{"elapsed":36,"status":"ok","timestamp":1630058016612,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"TemcqrMsa-ww"},"outputs":[],"source":["with open(text_file) as f:\n","    lines = f.read().split(\"\\n\")[:-1]\n","text_pairs = []\n","for line in lines:\n","    inp, targ = line.split(\"\\t\")\n","    targ = \"[start] \" + targ + \" [end]\"\n","    text_pairs.append((inp, targ))"]},{"cell_type":"markdown","metadata":{"id":"uVT6PBMga-wx"},"source":["Here's what our sentence pairs look like:"]},{"cell_type":"code","execution_count":6,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":34,"status":"ok","timestamp":1630058016613,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"RVHW_4Gva-wy","outputId":"9b11f4d8-3c61-4782-a13a-39f65bc43f36"},"outputs":[{"name":"stdout","output_type":"stream","text":["('ÿßŸÜÿ™ŸÅÿßŸáŸÖ ÿ®ŸäŸÜÿß ÿßÿ∑ŸÑÿπ ŸÖŸÜŸáÿß Ÿäÿß ŸÜŸäÿ¨Ÿäÿ±Ÿäÿß Ÿäÿß ÿÆÿØŸÖŸâ üëπüëπüëπ Ÿà ÿµÿ®ÿßÿßÿßÿßÿßÿßÿ≠ŸÉ ‚ù§Ô∏è', '[start] ÿßŸÜÿ™ŸÅÿßŸáŸÖ ÿ®ŸäŸÜÿß ÿßÿ∑ŸÑÿπ ŸÖŸÜŸáÿß Ÿäÿß ŸÜŸäÿ¨Ÿäÿ±Ÿäÿß Ÿäÿß ÿÆÿØŸÖŸâ üëπüëπüëπ Ÿà ÿµÿ®ÿßÿßÿßÿßÿßÿßÿ≠ŸÉ ‚ù§Ô∏è [end]')\n","('Ÿàÿ™ÿ∑ŸÑÿßŸÑÿ® Ÿäÿß ÿßÿπŸÑÿßŸÖ Ÿäÿß ŸÑŸäÿ®Ÿä ÿ∑Ÿäÿ≠ ŸàÿßŸÑŸÑŸá ÿ≥ÿπÿØŸÉŸÖ ŸàŸÖÿ≤ÿßŸÑŸÉŸÖ', '[start] Ÿàÿ™ÿ∑ŸÑÿßŸÑÿ® Ÿäÿß ÿßÿπŸÑÿßŸÖ Ÿäÿß ŸÑŸäÿ®Ÿä *** ŸàÿßŸÑŸÑŸá ÿ≥ÿπÿØŸÉŸÖ ŸàŸÖÿ≤ÿßŸÑŸÉŸÖ [end]')\n","('ÿ•ŸàÿπŸâ ÿ™ÿ®ÿ∑ŸÑ ÿ£ŸÉŸÑ Ÿäÿß ŸÖÿ™ÿ£ŸÜŸä Ÿäÿß ŸÉŸèÿ±ÿ®ÿßÿ¨ Ÿäÿß ŸÖŸÇŸÑŸàÿ∏ ÿ•ŸÜÿ™ Ÿäÿßÿ¨ŸäŸÑŸâ ÿ®ÿßŸÑŸÖŸáŸÑÿ®ŸäŸá.\"', '[start] ÿ•ŸàÿπŸâ ÿ™ÿ®ÿ∑ŸÑ ÿ£ŸÉŸÑ Ÿäÿß ŸÖÿ™ÿ£ŸÜŸä Ÿäÿß ŸÉŸèÿ±ÿ®ÿßÿ¨ Ÿäÿß ***** ÿ•ŸÜÿ™ Ÿäÿßÿ¨ŸäŸÑŸâ ÿ®ÿßŸÑŸÖŸáŸÑÿ®ŸäŸá.\" [end]')\n","('ŸÇŸÑ Ÿäÿß ŸÉŸÑÿ® Ÿäÿß ŸÖÿ±ÿ™ÿ≤ŸÇ Ÿäÿß ŸÖÿ¥ÿ±ÿØ Ÿäÿß ÿ≥ÿπÿØ ÿßŸÑÿ≥ŸÅŸäŸá ÿπŸÖŸä ŸàŸÑŸä ÿßŸÑÿπŸáÿØ ŸÖÿ≠ŸÖÿØ ÿ®ŸÜ ÿ≥ŸÑŸÖÿßŸÜ ÿßŸÑŸÜÿßÿ≥ ŸÖŸÇÿßŸÖÿßÿ™ ŸàŸÖŸÇÿßŸÖŸÉ Ÿäÿß ÿ™ÿ±ŸÉŸä ÿßŸÑÿ¥ŸÑŸáŸàÿ® ÿπŸÜÿØ ÿßŸÑŸÜÿπÿßŸÑ', '[start] ŸÇŸÑ Ÿäÿß ***Ÿäÿß *****Ÿäÿß ****Ÿäÿß ÿ≥ÿπÿØ ÿßŸÑ**** ÿπŸÖŸä ŸàŸÑŸä ÿßŸÑÿπŸáÿØ ŸÖÿ≠ŸÖÿØ ÿ®ŸÜ ÿ≥ŸÑŸÖÿßŸÜ ÿßŸÑŸÜÿßÿ≥ ŸÖŸÇÿßŸÖÿßÿ™ ŸàŸÖŸÇÿßŸÖŸÉ Ÿäÿß ÿ™ÿ±ŸÉŸä ÿßŸÑÿ¥ŸÑŸáŸàÿ® ÿπŸÜÿØ ÿßŸÑ**** [end]')\n","('ÿßŸä ÿµÿ≠ ÿ¥ÿ∞Ÿâ ÿ™ÿ∞ŸÉÿ±ŸäŸÜ ÿ®ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑ Ÿäÿß ÿ≠ŸÇŸäÿ±ÿ© ŸäŸàŸÖ ÿ™ÿµŸäÿ≠ŸäŸÜ ÿπŸÑÿ¥ÿßŸÜ ŸÜÿµ ÿØÿ±ÿ¨ÿ© Ÿàÿßÿ¨Ÿä ÿ£ÿ∫ÿ∑Ÿä ÿπŸÑŸäŸÉ ŸàÿßŸÇŸàŸÑ ÿßŸÜŸá ÿπŸäŸàŸÜŸÉ ÿØÿÆŸÑ ŸÅŸäŸáÿß ÿ¥Ÿäÿ° Ÿäÿß ÿπÿØŸäŸÖÿ© ÿßŸÑÿ•ÿ≠ÿ≥ÿßÿ≥ Ÿäÿß ÿ¨ÿßÿ≠ÿØÿ© Ÿäÿß ŸÜÿßŸÉÿ±ÿ© ŸÑŸÑÿ¨ŸÖŸäŸÑ', '[start] ÿßŸä ÿµÿ≠ ÿ¥ÿ∞Ÿâ ÿ™ÿ∞ŸÉÿ±ŸäŸÜ ÿ®ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑ Ÿäÿß *****ŸäŸàŸÖ ÿ™ÿµŸäÿ≠ŸäŸÜ ÿπŸÑÿ¥ÿßŸÜ ŸÜÿµ ÿØÿ±ÿ¨ÿ© Ÿàÿßÿ¨Ÿä ÿ£ÿ∫ÿ∑Ÿä ÿπŸÑŸäŸÉ ŸàÿßŸÇŸàŸÑ ÿßŸÜŸá ÿπŸäŸàŸÜŸÉ ÿØÿÆŸÑ ŸÅŸäŸáÿß ÿ¥Ÿäÿ° Ÿäÿß ***** ÿßŸÑÿ•ÿ≠ÿ≥ÿßÿ≥ Ÿäÿß ÿ¨ÿßÿ≠ÿØÿ© Ÿäÿß *****ŸÑŸÑÿ¨ŸÖŸäŸÑ [end]')\n"]}],"source":["for _ in range(5):\n","    print(random.choice(text_pairs))"]},{"cell_type":"markdown","metadata":{"id":"Z5tRhKiMa-wz"},"source":["Now, let's split the sentence pairs into a training set, a validation set,\n","and a test set."]},{"cell_type":"code","execution_count":7,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":25,"status":"ok","timestamp":1630058016614,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"8mUPXPWYa-wz","outputId":"0ce000ae-dbdd-4016-d067-e21be76ee6f1"},"outputs":[{"name":"stdout","output_type":"stream","text":["1591 total pairs\n","1194 training pairs\n","397 validation pairs\n"]}],"source":["random.shuffle(text_pairs)\n","num_val_samples = int(0.25 * len(text_pairs))\n","num_train_samples = len(text_pairs) -  num_val_samples\n","train_pairs = text_pairs[:num_train_samples]\n","val_pairs = text_pairs[num_train_samples : num_train_samples + num_val_samples]\n","# test_pairs = text_pairs[num_train_samples + num_val_samples :]\n","\n","print(f\"{len(text_pairs)} total pairs\")\n","print(f\"{len(train_pairs)} training pairs\")\n","print(f\"{len(val_pairs)} validation pairs\")\n","# print(f\"{len(test_pairs)} test pairs\")"]},{"cell_type":"code","execution_count":8,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":501,"status":"ok","timestamp":1630058017105,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"IfI1L6L2l-bh","outputId":"cb04158e-db36-4ea2-d58f-5516d839385b"},"outputs":[{"name":"stdout","output_type":"stream","text":["('ŸÑÿπŸÜ ÿßŸÑŸÑŸá ÿßŸÖŸÉ Ÿäÿß ÿ™ÿ±ŸÉŸä Ÿäÿß ŸÉŸÑÿ® Ÿäÿß ÿ¥ÿßŸÉŸäŸäÿ±', '[start] *** ÿßŸÑŸÑŸá ÿßŸÖŸÉ Ÿäÿß ÿ™ÿ±ŸÉŸä Ÿäÿß *** Ÿäÿß ÿ¥ÿßŸÉŸäŸäÿ± [end]')\n","('Ÿäÿß ÿ≠Ÿàÿ´ŸäŸá Ÿäÿß ÿÆÿßŸäŸÜŸá Ÿäÿß ŸÉÿ∞ÿßÿ®Ÿá', '[start] Ÿäÿß ***** Ÿäÿß ***** Ÿäÿß ***** [end]')\n","('#ÿ∂ÿØ_ÿßŸÑÿ≥ŸÜÿßÿ®_ÿßŸÑÿßŸÖŸÜŸä_ÿßŸÑÿπŸÜÿµÿ±Ÿä ŸÖÿ¨ÿ™ŸÖÿπŸÉŸÖ ŸÉŸÑŸá ÿπŸÜÿµÿ±Ÿä .. Ÿäÿß ÿπÿ®ÿØ Ÿäÿß ŸÉŸàŸäÿ≠Ÿá Ÿäÿß ÿ∑ÿπÿ≥ Ÿäÿß ÿ∑ÿ±ÿ¥ Ÿäÿß ÿµŸÅÿ± ÿ≥ÿ®ÿπŸá Ÿäÿß ŸÑÿ≠ÿ¨Ÿä Ÿäÿß ŸÖÿÆŸÑŸÅÿßÿ™ ÿ≠ÿ¨ÿßÿ¨ ÿßŸÑŸÑŸá Ÿäÿ±ÿ≠ŸÖ ÿßŸÑŸÖŸÑŸÉ ŸÅŸäÿµŸÑ Ÿäÿß ÿ≠ŸÜÿ≥ Ÿàÿ∫Ÿäÿ±Ÿáÿß .. Ÿàÿßÿ∂ÿ≠ ÿßŸÜŸá ÿ™ÿ¨ÿßŸàÿ≤ŸáŸÖ ÿ®ÿ≥ÿ®ÿ® ÿπŸÜÿµÿ±Ÿä ŸàÿßŸÑŸÖÿ∂ÿ≠ŸÉ ÿ™ÿ±ŸÇŸäÿπÿ™Ÿá ÿßŸÜ ŸÅŸäŸá ÿµŸàÿ™ Ÿàÿßÿ≠ÿØ ŸÖÿπÿµÿ® ÿ≥ÿ®ŸáÿßŸÜ ÿßŸÑŸÑŸá üòÅ ÿ≤ŸàÿØ ÿπŸÑŸâ ÿßŸÑŸäÿ™ŸÖ ÿπŸÜÿµÿ±ŸäŸá .. ŸÑÿßÿ≤ŸÖ Ÿäÿ™ÿ≠ÿßÿ≥ÿ®', '[start] #ÿ∂ÿØ_ÿßŸÑÿ≥ŸÜÿßÿ®_ÿßŸÑÿßŸÖŸÜŸä_ÿßŸÑÿπŸÜÿµÿ±Ÿä ŸÖÿ¨ÿ™ŸÖÿπŸÉŸÖ ŸÉŸÑŸá ***** .. Ÿäÿß *** Ÿäÿß ***** Ÿäÿß *** Ÿäÿß *** Ÿäÿß *** ÿ≥ÿ®ÿπŸá Ÿäÿß **** Ÿäÿß ****** ÿ≠ÿ¨ÿßÿ¨ ÿßŸÑŸÑŸá Ÿäÿ±ÿ≠ŸÖ ÿßŸÑŸÖŸÑŸÉ ŸÅŸäÿµŸÑ Ÿäÿß ÿ≠ŸÜÿ≥ Ÿàÿ∫Ÿäÿ±Ÿáÿß .. Ÿàÿßÿ∂ÿ≠ ÿßŸÜŸá ÿ™ÿ¨ÿßŸàÿ≤ŸáŸÖ ÿ®ÿ≥ÿ®ÿ® ***** ŸàÿßŸÑŸÖÿ∂ÿ≠ŸÉ ÿ™ÿ±ŸÇŸäÿπÿ™Ÿá ÿßŸÜ ŸÅŸäŸá ÿµŸàÿ™ Ÿàÿßÿ≠ÿØ **** ÿ≥ÿ®ŸáÿßŸÜ ÿßŸÑŸÑŸá üòÅ ÿ≤ŸàÿØ ÿπŸÑŸâ ÿßŸÑŸäÿ™ŸÖ ****** .. ŸÑÿßÿ≤ŸÖ Ÿäÿ™ÿ≠ÿßÿ≥ÿ® [end]')\n","('ÿ≠ŸÅŸÑŸà ÿßŸÉÿ™ÿ± Ÿäÿß ŸàŸÑÿßÿØ ÿßŸÑÿßŸÉŸÑÿßÿ® Ÿáÿ±ÿ®ŸäŸÉŸä Ÿäÿß ÿßÿ≥ÿ±ÿßÿ° Ÿäÿß Ÿàÿ≥ÿÆŸáüòÇüòÇüòÇüòÇüòÇüòÇ', '[start] ÿ≠ŸÅŸÑŸà ÿßŸÉÿ™ÿ± Ÿäÿß ŸàŸÑÿßÿØ ******* ****** Ÿäÿß ÿßÿ≥ÿ±ÿßÿ° Ÿäÿß ****üòÇüòÇüòÇüòÇüòÇüòÇ [end]')\n","('ŸáŸàŸá ÿßŸÜÿß ŸÑŸäŸá ŸÖÿ≠ÿØÿ¥ ÿ®Ÿäÿ®ÿπÿ™ ÿµŸàÿ±ÿ™Ÿä ŸÅŸä ÿßŸÑŸÑÿπÿ® ÿØŸä ŸáŸàŸá ÿßŸÜÿß ŸÖÿ∂ÿ≠ŸÉÿ™ÿ¥ ÿ≠ÿØ ŸÇÿ®ŸÑ ŸÉÿØÿ© Ÿäÿß ŸÜÿßŸÉÿ±ŸäŸÜ ÿßŸÑÿ¨ŸÖŸäŸÑ Ÿäÿß ŸÉŸÑÿßÿ® üòÇüòÇ', '[start] ŸáŸàŸá ÿßŸÜÿß ŸÑŸäŸá ŸÖÿ≠ÿØÿ¥ ÿ®Ÿäÿ®ÿπÿ™ ÿµŸàÿ±ÿ™Ÿä ŸÅŸä ÿßŸÑŸÑÿπÿ® ÿØŸä ŸáŸàŸá ÿßŸÜÿß ŸÖÿ∂ÿ≠ŸÉÿ™ÿ¥ ÿ≠ÿØ ŸÇÿ®ŸÑ ŸÉÿØÿ© Ÿäÿß ŸÜÿßŸÉÿ±ŸäŸÜ ÿßŸÑÿ¨ŸÖŸäŸÑ Ÿäÿß **** üòÇüòÇ [end]')\n","401 test pairs\n"]}],"source":["test_file = pathlib.Path('/content/drive/MyDrive/MasterThesis/paraphrasing/paraphrasingTest.tsv')\n","with open(test_file) as f:\n","    lines = f.read().split(\"\\n\")[:-1]\n","test_pairs = []\n","for line in lines:\n","    inp, targ = line.split(\"\\t\")\n","    targ = \"[start] \" + targ + \" [end]\"\n","    test_pairs.append((inp, targ))\n","\n","for _ in range(5):\n","    print(random.choice(test_pairs))\n","\n","random.shuffle(test_pairs)\n","num_test_samples = len(test_pairs)\n","test_pairs = test_pairs[: num_test_samples]\n","print(f\"{len(test_pairs)} test pairs\")"]},{"cell_type":"markdown","metadata":{"id":"1CpqzqNaa-w0"},"source":["## Vectorizing the text data\n","\n","We'll use two instances of the `TextVectorization` layer to vectorize the text\n","data (one for English and one for Spanish),\n","that is to say, to turn the original strings into integer sequences\n","where each integer represents the index of a word in a vocabulary.\n","\n","The English layer will use the default string standardization (strip punctuation characters)\n","and splitting scheme (split on whitespace), while\n","the Spanish layer will use a custom standardization, where we add the character\n","`\"¬ø\"` to the set of punctuation characters to be stripped.\n","\n","Note: in a production-grade machine translation model, I would not recommend\n","stripping the punctuation characters in either language. Instead, I would recommend turning\n","each punctuation character into its own token,\n","which you could achieve by providing a custom `split` function to the `TextVectorization` layer."]},{"cell_type":"code","execution_count":9,"metadata":{"executionInfo":{"elapsed":661,"status":"ok","timestamp":1630058017762,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"CPoQesZea-w0"},"outputs":[],"source":["# strip_chars = string.punctuation + \"¬ø\"\n","strip_chars = \"[a-zA-Z]|\\d+|[Ÿ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©]|[.#ÿå\u003c\u003e@,\\\\-_‚Äù‚ÄúŸ™ŸéŸã]\"\n","\n","strip_chars = strip_chars.replace(\"[\", \"\")\n","strip_chars = strip_chars.replace(\"]\", \"\")\n","\n","vocab_size = 7000\n","sequence_length = 20\n","batch_size = 64\n","\n","\n","def custom_standardization(input_string):\n","    lowercase = tf.strings.lower(input_string)\n","    return tf.strings.regex_replace(lowercase, \"[%s]\" % re.escape(strip_chars), \"\")\n","\n","\n","inp_vectorization = TextVectorization(\n","    max_tokens=vocab_size, output_mode=\"int\", output_sequence_length=sequence_length,\n",")\n","targ_vectorization = TextVectorization(\n","    max_tokens=vocab_size,\n","    output_mode=\"int\",\n","    output_sequence_length=sequence_length + 1,\n","    standardize=custom_standardization,\n",")\n","train_eng_texts = [pair[0] for pair in train_pairs]\n","train_spa_texts = [pair[1] for pair in train_pairs]\n","inp_vectorization.adapt(train_eng_texts)\n","targ_vectorization.adapt(train_spa_texts)"]},{"cell_type":"markdown","metadata":{"id":"8enIADXMa-w1"},"source":["Next, we'll format our datasets.\n","\n","At each training step, the model will seek to predict target words N+1 (and beyond)\n","using the source sentence and the target words 0 to N.\n","\n","As such, the training dataset will yield a tuple `(inputs, targets)`, where:\n","\n","- `inputs` is a dictionary with the keys `encoder_inputs` and `decoder_inputs`.\n","`encoder_inputs` is the vectorized source sentence and `encoder_inputs` is the target sentence \"so far\",\n","that is to say, the words 0 to N used to predict word N+1 (and beyond) in the target sentence.\n","- `target` is the target sentence offset by one step:\n","it provides the next words in the target sentence -- what the model will try to predict."]},{"cell_type":"code","execution_count":10,"metadata":{"executionInfo":{"elapsed":309,"status":"ok","timestamp":1630058018062,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"dKmCVA5Ka-w2"},"outputs":[],"source":["\n","def format_dataset(inp, targ):\n","    inp = inp_vectorization(inp)\n","    targ = targ_vectorization(targ)\n","    return ({\"encoder_inputs\": inp, \"decoder_inputs\": targ[:, :-1],}, targ[:, 1:])\n","\n","\n","def make_dataset(pairs):\n","    inp_texts, targ_texts = zip(*pairs)\n","    inp_texts = list(inp_texts)\n","    targ_texts = list(targ_texts)\n","    dataset = tf.data.Dataset.from_tensor_slices((inp_texts, targ_texts))\n","    dataset = dataset.batch(batch_size)\n","    dataset = dataset.map(format_dataset)\n","    return dataset.shuffle(248).prefetch(16).cache()\n","\n","\n","train_ds = make_dataset(train_pairs)\n","val_ds = make_dataset(val_pairs)"]},{"cell_type":"markdown","metadata":{"id":"U6ZQPBz4a-w3"},"source":["Let's take a quick look at the sequence shapes\n","(we have batches of 64 pairs, and all sequences are 20 steps long):"]},{"cell_type":"code","execution_count":11,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":506,"status":"ok","timestamp":1630058018565,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"PkVSFSxBa-w3","outputId":"1a209aed-b9a7-4ec6-e100-ccf89e749113"},"outputs":[{"name":"stdout","output_type":"stream","text":["inputs[\"encoder_inputs\"].shape: (64, 20)\n","inputs[\"decoder_inputs\"].shape: (64, 20)\n","targets.shape: (64, 20)\n"]}],"source":["for inputs, targets in train_ds.take(1):\n","    print(f'inputs[\"encoder_inputs\"].shape: {inputs[\"encoder_inputs\"].shape}')\n","    print(f'inputs[\"decoder_inputs\"].shape: {inputs[\"decoder_inputs\"].shape}')\n","    print(f\"targets.shape: {targets.shape}\")"]},{"cell_type":"markdown","metadata":{"id":"GQ6z9fVea-w3"},"source":["## Building the model\n","\n","Our sequence-to-sequence Transformer consists of a `TransformerEncoder`\n","and a `TransformerDecoder` chained together. To make the model aware of word order,\n","we also use a `PositionalEmbedding` layer.\n","\n","The source sequence will be pass to the `TransformerEncoder`,\n","which will produce a new representation of it.\n","This new representation will then be passed\n","to the `TransformerDecoder`, together with the target sequence so far (target words 0 to N).\n","The `TransformerDecoder` will then seek to predict the next words in the target sequence (N+1 and beyond).\n","\n","A key detail that makes this possible is causal masking\n","(see method `get_causal_attention_mask()` on the `TransformerDecoder`).\n","The `TransformerDecoder` sees the entire sequences at once, and thus we must make\n","sure that it only uses information from target tokens 0 to N when predicting token N+1\n","(otherwise, it could use information from the future, which would\n","result in a model that cannot be used at inference time)."]},{"cell_type":"code","execution_count":12,"metadata":{"executionInfo":{"elapsed":5,"status":"ok","timestamp":1630058018566,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"3jHRvQaHa-w3"},"outputs":[],"source":["\n","class TransformerEncoder(layers.Layer):\n","    def __init__(self, embed_dim, dense_dim, num_heads, **kwargs):\n","        super(TransformerEncoder, self).__init__(**kwargs)\n","        self.embed_dim = embed_dim\n","        self.dense_dim = dense_dim\n","        self.num_heads = num_heads\n","        self.attention = layers.MultiHeadAttention(\n","            num_heads=num_heads, key_dim=embed_dim\n","        )\n","        self.dense_proj = keras.Sequential(\n","            [layers.Dense(dense_dim, activation=\"relu\"), layers.Dense(embed_dim),]\n","        )\n","        self.layernorm_1 = layers.LayerNormalization()\n","        self.layernorm_2 = layers.LayerNormalization()\n","        self.supports_masking = True\n","\n","    def call(self, inputs, mask=None):\n","        if mask is not None:\n","            padding_mask = tf.cast(mask[:, tf.newaxis, tf.newaxis, :], dtype=\"int32\")\n","        attention_output = self.attention(\n","            query=inputs, value=inputs, key=inputs, attention_mask=padding_mask\n","        )\n","        proj_input = self.layernorm_1(inputs + attention_output)\n","        proj_output = self.dense_proj(proj_input)\n","        return self.layernorm_2(proj_input + proj_output)\n","\n","\n","class PositionalEmbedding(layers.Layer):\n","    def __init__(self, sequence_length, vocab_size, embed_dim, **kwargs):\n","        super(PositionalEmbedding, self).__init__(**kwargs)\n","        self.token_embeddings = layers.Embedding(\n","            input_dim=vocab_size, output_dim=embed_dim\n","        )\n","        self.position_embeddings = layers.Embedding(\n","            input_dim=sequence_length, output_dim=embed_dim\n","        )\n","        self.sequence_length = sequence_length\n","        self.vocab_size = vocab_size\n","        self.embed_dim = embed_dim\n","\n","    def call(self, inputs):\n","        length = tf.shape(inputs)[-1]\n","        positions = tf.range(start=0, limit=length, delta=1)\n","        embedded_tokens = self.token_embeddings(inputs)\n","        embedded_positions = self.position_embeddings(positions)\n","        return embedded_tokens + embedded_positions\n","\n","    def compute_mask(self, inputs, mask=None):\n","        return tf.math.not_equal(inputs, 0)\n","\n","\n","class TransformerDecoder(layers.Layer):\n","    def __init__(self, embed_dim, latent_dim, num_heads, **kwargs):\n","        super(TransformerDecoder, self).__init__(**kwargs)\n","        self.embed_dim = embed_dim\n","        self.latent_dim = latent_dim\n","        self.num_heads = num_heads\n","        self.attention_1 = layers.MultiHeadAttention(\n","            num_heads=num_heads, key_dim=embed_dim\n","        )\n","        self.attention_2 = layers.MultiHeadAttention(\n","            num_heads=num_heads, key_dim=embed_dim\n","        )\n","        self.dense_proj = keras.Sequential(\n","            [layers.Dense(latent_dim, activation=\"relu\"), layers.Dense(embed_dim),]\n","        )\n","        self.layernorm_1 = layers.LayerNormalization()\n","        self.layernorm_2 = layers.LayerNormalization()\n","        self.layernorm_3 = layers.LayerNormalization()\n","        self.supports_masking = True\n","\n","    def call(self, inputs, encoder_outputs, mask=None):\n","        causal_mask = self.get_causal_attention_mask(inputs)\n","        if mask is not None:\n","            padding_mask = tf.cast(mask[:, tf.newaxis, :], dtype=\"int32\")\n","            padding_mask = tf.minimum(padding_mask, causal_mask)\n","\n","        attention_output_1 = self.attention_1(\n","            query=inputs, value=inputs, key=inputs, attention_mask=causal_mask\n","        )\n","        out_1 = self.layernorm_1(inputs + attention_output_1)\n","\n","        attention_output_2 = self.attention_2(\n","            query=out_1,\n","            value=encoder_outputs,\n","            key=encoder_outputs,\n","            attention_mask=padding_mask,\n","        )\n","        out_2 = self.layernorm_2(out_1 + attention_output_2)\n","\n","        proj_output = self.dense_proj(out_2)\n","        return self.layernorm_3(out_2 + proj_output)\n","\n","    def get_causal_attention_mask(self, inputs):\n","        input_shape = tf.shape(inputs)\n","        batch_size, sequence_length = input_shape[0], input_shape[1]\n","        i = tf.range(sequence_length)[:, tf.newaxis]\n","        j = tf.range(sequence_length)\n","        mask = tf.cast(i \u003e= j, dtype=\"int32\")\n","        mask = tf.reshape(mask, (1, input_shape[1], input_shape[1]))\n","        mult = tf.concat(\n","            [tf.expand_dims(batch_size, -1), tf.constant([1, 1], dtype=tf.int32)],\n","            axis=0,\n","        )\n","        return tf.tile(mask, mult)\n"]},{"cell_type":"markdown","metadata":{"id":"WCD0jPjqa-w4"},"source":["Next, we assemble the end-to-end model."]},{"cell_type":"code","execution_count":13,"metadata":{"executionInfo":{"elapsed":3219,"status":"ok","timestamp":1630058021781,"user":{"displayName":"Do salam","photoUrl":"https://lh3.googleusercontent.com/a-/AOh14GgP0GyFxHH-3NAPSZ_ethp4uMqaN8pUWhOxcO0NDw=s64","userId":"03587359084159229589"},"user_tz":-180},"id":"PaxOj5PWa-w5"},"outputs":[],"source":["embed_dim = 256\n","latent_dim = 2048\n","num_heads = 8\n","\n","encoder_inputs = keras.Input(shape=(None,), dtype=\"int64\", name=\"encoder_inputs\")\n","x = PositionalEmbedding(sequence_length, vocab_size, embed_dim)(encoder_inputs)\n","encoder_outputs = TransformerEncoder(embed_dim, latent_dim, num_heads)(x)\n","encoder = keras.Model(encoder_inputs, encoder_outputs)\n","\n","decoder_inputs = keras.Input(shape=(None,), dtype=\"int64\", name=\"decoder_inputs\")\n","encoded_seq_inputs = keras.Input(shape=(None, embed_dim), name=\"decoder_state_inputs\")\n","x = PositionalEmbedding(sequence_length, vocab_size, embed_dim)(decoder_inputs)\n","# x = layers.Dropout(0.5)(x)\n","\n","x = TransformerDecoder(embed_dim, latent_dim, num_heads)(x, encoded_seq_inputs)\n","# x = layers.Dropout(0.5)(x)\n","decoder_outputs = layers.Dense(vocab_size, activation=\"softmax\")(x)\n","x = layers.Dropout(0.2)(x)\n","\n","decoder = keras.Model([decoder_inputs, encoded_seq_inputs], decoder_outputs)\n","\n","decoder_outputs = decoder([decoder_inputs, encoder_outputs])\n","transformer = keras.Model(\n","    [encoder_inputs, decoder_inputs], decoder_outputs, name=\"transformer\"\n",")"]},{"cell_type":"markdown","metadata":{"id":"9dFxoe3ma-w5"},"source":["## Training our model\n","\n","We'll use accuracy as a quick way to monitor training progress on the validation data.\n","Note that machine translation typically uses BLEU scores as well as other metrics, rather than accuracy.\n","\n","Here we only train for 1 epoch, but to get the model to actually converge\n","you should train for at least 30 epochs."]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true,"base_uri":"https://localhost:8080/"},"id":"8tGD8iZLa-w6"},"outputs":[{"name":"stdout","output_type":"stream","text":["Model: \"transformer\"\n","__________________________________________________________________________________________________\n","Layer (type)                    Output Shape         Param #     Connected to                     \n","==================================================================================================\n","encoder_inputs (InputLayer)     [(None, None)]       0                                            \n","__________________________________________________________________________________________________\n","positional_embedding (Positiona (None, None, 256)    1797120     encoder_inputs[0][0]             \n","__________________________________________________________________________________________________\n","decoder_inputs (InputLayer)     [(None, None)]       0                                            \n","__________________________________________________________________________________________________\n","transformer_encoder (Transforme (None, None, 256)    3155456     positional_embedding[0][0]       \n","__________________________________________________________________________________________________\n","model_1 (Functional)            (None, None, 7000)   8855640     decoder_inputs[0][0]             \n","                                                                 transformer_encoder[0][0]        \n","==================================================================================================\n","Total params: 13,808,216\n","Trainable params: 13,808,216\n","Non-trainable params: 0\n","__________________________________________________________________________________________________\n","Epoch 1/30\n","19/19 [==============================] - 48s 2s/step - loss: 5.6489 - accuracy: 0.1285 - val_loss: 3.7187 - val_accuracy: 0.1526\n","Epoch 2/30\n","19/19 [==============================] - 42s 2s/step - loss: 5.1631 - accuracy: 0.1324 - val_loss: 3.6431 - val_accuracy: 0.3514\n","Epoch 3/30\n","19/19 [==============================] - 42s 2s/step - loss: 4.9449 - accuracy: 0.2021 - val_loss: 3.7634 - val_accuracy: 0.4231\n","Epoch 4/30\n","19/19 [==============================] - 42s 2s/step - loss: 4.7249 - accuracy: 0.2421 - val_loss: 3.3290 - val_accuracy: 0.4322\n","Epoch 5/30\n","19/19 [==============================] - 42s 2s/step - loss: 4.5505 - accuracy: 0.2553 - val_loss: 3.5409 - val_accuracy: 0.3939\n","Epoch 6/30\n","19/19 [==============================] - 41s 2s/step - loss: 4.1561 - accuracy: 0.2853 - val_loss: 3.2192 - val_accuracy: 0.4214\n","Epoch 7/30\n","19/19 [==============================] - 41s 2s/step - loss: 3.9061 - accuracy: 0.3078 - val_loss: 3.0721 - val_accuracy: 0.4714\n","Epoch 8/30\n","19/19 [==============================] - 43s 2s/step - loss: 3.4114 - accuracy: 0.3574 - val_loss: 3.2820 - val_accuracy: 0.4864\n","Epoch 9/30\n","19/19 [==============================] - 43s 2s/step - loss: 3.0523 - accuracy: 0.4271 - val_loss: 3.2528 - val_accuracy: 0.4484\n","Epoch 10/30\n","19/19 [==============================] - 42s 2s/step - loss: 2.6903 - accuracy: 0.5063 - val_loss: 2.9212 - val_accuracy: 0.5133\n","Epoch 11/30\n","19/19 [==============================] - 42s 2s/step - loss: 2.3365 - accuracy: 0.5708 - val_loss: 2.8486 - val_accuracy: 0.5052\n","Epoch 12/30\n","19/19 [==============================] - 42s 2s/step - loss: 1.9447 - accuracy: 0.6404 - val_loss: 3.3994 - val_accuracy: 0.4123\n","Epoch 13/30\n","19/19 [==============================] - 41s 2s/step - loss: 1.5978 - accuracy: 0.7063 - val_loss: 2.7103 - val_accuracy: 0.5202\n","Epoch 14/30\n","19/19 [==============================] - 42s 2s/step - loss: 1.3292 - accuracy: 0.7578 - val_loss: 2.9062 - val_accuracy: 0.5008\n","Epoch 15/30\n","19/19 [==============================] - 42s 2s/step - loss: 1.0338 - accuracy: 0.8217 - val_loss: 3.2387 - val_accuracy: 0.4435\n","Epoch 16/30\n","19/19 [==============================] - 42s 2s/step - loss: 0.8011 - accuracy: 0.8719 - val_loss: 2.7262 - val_accuracy: 0.5240\n"]}],"source":["epochs = 30  # This should be at least 30 for convergence\n","my_callbacks = [\n","    tf.keras.callbacks.EarlyStopping(monitor='val_loss',patience=3),\n","    # tf.keras.callbacks.ReduceLROnPlateau(\n","    #   monitor='val_loss', factor=0.1, patience=2,\n","    #   min_lr=0,\n","    # )\n","]\n","\n","transformer.summary()\n","transformer.compile(\n","    \"rmsprop\", loss=\"sparse_categorical_crossentropy\", metrics=[\"accuracy\"]\n",")\n","\n","history  = transformer.fit(train_ds, epochs=epochs, validation_data=val_ds,callbacks=my_callbacks)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"AoxqTnCF_2tK"},"outputs":[{"data":{"text/plain":["\u003cmatplotlib.legend.Legend at 0x7f8539620e50\u003e"]},"execution_count":null,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"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\n","text/plain":["\u003cFigure size 432x288 with 2 Axes\u003e"]},"metadata":{},"output_type":"display_data"}],"source":["import matplotlib.pyplot as plt\n","\n","s, (at, al) = plt.subplots(2,1)\n","at.plot(history.history['accuracy'], c= 'b')\n","at.plot(history.history['val_accuracy'], c='r')\n","at.set_title('model accuracy')\n","at.set_ylabel('accuracy')\n","at.set_xlabel('epoch')\n","at.legend(['train', 'val'], loc='upper left')\n","\n","al.plot(history.history['loss'], c='m')\n","al.plot(history.history['val_loss'], c='c')\n","al.set_title('model loss')\n","al.set_ylabel('loss')\n","al.set_xlabel('epoch')\n","al.legend(['train', 'val'], loc = 'upper left')"]},{"cell_type":"markdown","metadata":{"id":"SL-vwLH1a-w6"},"source":["## Decoding test sentences\n","\n","Finally, let's demonstrate how to translate brand new English sentences.\n","We simply feed into the model the vectorized English sentence\n","as well as the target token `\"[start]\"`, then we repeatedly generated the next token, until\n","we hit the token `\"[end]\"`."]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"okeujBqTa-w6"},"outputs":[],"source":["spa_vocab = targ_vectorization.get_vocabulary()\n","spa_index_lookup = dict(zip(range(len(spa_vocab)), spa_vocab))\n","max_decoded_sentence_length = 20\n","\n","\n","def decode_sequence(input_sentence):\n","    tokenized_input_sentence = inp_vectorization([input_sentence])\n","    decoded_sentence = \"[start]\"\n","    for i in range(max_decoded_sentence_length):\n","        tokenized_target_sentence = targ_vectorization([decoded_sentence])[:, :-1]\n","        predictions = transformer([tokenized_input_sentence, tokenized_target_sentence])\n","\n","        sampled_token_index = np.argmax(predictions[0, i, :])\n","        sampled_token = spa_index_lookup[sampled_token_index]\n","        decoded_sentence += \" \" + sampled_token\n","\n","        if sampled_token == \"[end]\":\n","            break\n","    return decoded_sentence\n","\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"qZlMgW0dnxno"},"outputs":[],"source":["# from nltk.translate.bleu_score import corpus_bleu\n","# from nltk.translate.bleu_score import sentence_bleu\n","# predicted_list = []\n","# test_inp_texts = [pair[0] for pair in test_pairs]\n","# test_targ_texts = [pair[1] for pair in test_pairs]\n","\n","# score_list = []\n","# from nltk.translate.bleu_score import SmoothingFunction\n","# # print(len(test_inp_texts))\n","# # print(len(test_targ_texts))\n","# # def bleu_score():\n","\n","# for i,j in zip(test_inp_texts,test_targ_texts):\n","\n","#   input_sentence = test_inp_texts\n","#     # print(input_sentence[i])\n","#   translated = decode_sequence(i)\n","#   predicted = list(translated.split(\",\"))\n","#   score = sentence_bleu(i, translated, weights=(1, 0, 0, 0))\n","#   score_list.append(score)\n","#   predicted_list.append(predicted)\n","#   print(\"Input:\",i,\"\\n Actual\",j,\"\\n Predicted\",translated)\n","#   score = sentence_bleu(i, translated, weights=(1, 0, 0, 0))\n","#   print(\"blue score : \",score,\"\\n\\n\")\n","# avg = sum(score_list) / len(score_list)\n","# print(\"Average of the list =\", round(avg, 2))\n","\n","#   # return bleu_dic\n","\n","\n","# # bleu_score()\n","# # bleu_test"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hiKXV65HxspA"},"outputs":[],"source":["from nltk.translate.bleu_score import corpus_bleu\n","from nltk.translate.bleu_score import sentence_bleu\n","predicted_list = []\n","test_inp_texts = [pair[0] for pair in test_pairs]\n","test_targ_texts = [pair[1] for pair in test_pairs]\n","\n","score_list = []\n","score_list_2 = []\n","score_list_3 = []\n","score_list_4 = []\n","from nltk.translate.bleu_score import SmoothingFunction\n","# print(len(test_inp_texts))\n","# print(len(test_targ_texts))\n","# def bleu_score():\n","\n","for i,j in zip(test_inp_texts,test_targ_texts):\n","\n","  input_sentence = test_inp_texts\n","    # print(input_sentence[i])\n","  translated = decode_sequence(i)\n","  predicted = list(translated.split(\",\"))\n","  # score = sentence_bleu(i, translated, weights=(1, 0, 0, 0))\n","  score_1 = sentence_bleu(i, translated, weights=(1, 0, 0, 0))\n","  score_2 = sentence_bleu(i, translated,weights=(0.5, 0.5, 0, 0))\n","  score_3 = sentence_bleu(i, translated, weights=(0.33, 0.33, 0.33, 0))\n","  score_4 = sentence_bleu(i, translated, weights=(0.25, 0.25, 0.25, 0.25))\n","  score_list.append(score_1)\n","  score_list_2.append(score_2)\n","  score_list_3.append(score_3)\n","  score_list_4.append(score_4)\n","  predicted_list.append(predicted)\n","  print(\"Input:\",i,\"\\n Actual\",j,\"\\n Predicted\",translated)\n","  # score_1 = sentence_bleu(i, translated, weights=(1, 0, 0, 0))\n","  # score_2 = sentence_bleu(i, translated,weights=(0.5, 0.5, 0, 0))\n","  # score_3 = sentence_bleu(i, translated, weights=(0.33, 0.33, 0.33, 0))\n","  # score_4 = sentence_bleu(i, translated, weights=(0.25, 0.25, 0.25, 0.25))\n","  print(\"blue 1-gram : \",score_1,\"\\n\",\"blue 2-gram : \",score_2,\"\\n\",\"blue 3-gram : \",score_3,\"\\n\",\"blue 4-gram : \",score_4,\"\\n\")\n","avg = sum(score_list) / len(score_list)\n","avg_2 = sum(score_list_2) / len(score_list_2)\n","avg_3 = sum(score_list_3) / len(score_list_3)\n","avg_4 = sum(score_list_4) / len(score_list_4)\n","print(\"Average of the list 1-gram=\", round(avg, 2),\"Average of the list 2-gram=\", round(avg_2, 2),\"Average of the list 3-gram=\", \n","      round(avg_3, 2),\"Average of the list 4-gram=\", round(avg_4, 2))\n","\n","  # return bleu_dic\n","\n","\n","# bleu_score()\n","# bleu_test"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"VjVwnT-tljio"},"outputs":[],"source":["# from nltk.translate.bleu_score import sentence_bleu,corpus_bleu\n","\n","# predicted_list = []\n","# test_inp_texts = [pair[0] for pair in test_pairs]\n","# test_targ_texts = [pair[1] for pair in test_pairs]\n","# for i,j in zip(test_inp_texts,test_targ_texts):\n","#     input_sentence = test_inp_texts\n","#     translated = decode_sequence(i)\n","#     predicted = list(translated.split(\",\"))\n","#     print(\"Input:\",i,\"\\n Actual\",j,\"\\n Predicted\",translated)\n","#     # print(translated)\n","  \n","#     # print(predicted)\n","#     score = sentence_bleu(i, translated, weights=(1, 0, 0, 0))\n","#     print(\"blue score : \",score,\"\\n\\n\")\n","   \n","#     predicted_list.append(predicted)\n","    \n","\n","# res = \"\\n\\n\\n\".join(\"Input: {} \\nActual: {} \\nPredicted: {}\".format(x, y,z) for x, y, z in zip(test_inp_texts[:5], test_targ_texts[:5], predicted_list[:5]))\n","# print(res)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"nxbDXWsZUVJf"},"outputs":[],"source":["# bleu_dic = {}\n","# bleu_dic['1-grams'] = sentence_bleu(test_targ_texts, predicted_list, weights=(1.0, 0, 0, 0))\n","# bleu_dic['1-2-grams'] = corpus_bleu(test_targ_texts, predicted_list, weights=(0.5, 0.5, 0, 0))\n","# bleu_dic['1-3-grams'] = corpus_bleu(test_targ_texts, predicted_list, weights=(0.3, 0.3, 0.3, 0))\n","# bleu_dic['1-4-grams'] = corpus_bleu(test_targ_texts, predicted_list, weights=(0.25, 0.25, 0.25, 0.25))   \n","\n","# print(\" \\n-------------\\n BLUE SCORE : \\n-------------\\n \",bleu_dic, \"\\n\\n\\n-------------\\n\")"]}],"metadata":{"colab":{"collapsed_sections":[],"name":"7000 | Paraphrasing | neural_machine_translation_with_transformer","provenance":[{"file_id":"16_nfzINfxjl0wXe7OmHg3R1YLoR-mcnp","timestamp":1629471209050},{"file_id":"1AKVcu4C08_OWa07Ghl84q6WmpijlrClk","timestamp":1629307981327},{"file_id":"1u2x4I-WagUER4QJNd4tt0bkz8ilfnDly","timestamp":1628998157816},{"file_id":"https://github.com/keras-team/keras-io/blob/master/examples/nlp/ipynb/neural_machine_translation_with_transformer.ipynb","timestamp":1628672106359}],"version":""},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.0"}},"nbformat":4,"nbformat_minor":0}